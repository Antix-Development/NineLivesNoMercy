<!DOCTYPE html>
<html lang="en" >
  <head>
    <meta charset="UTF-8">
    <title>ShrinkWrap</title>
		<style>
      :root {
        --background-color: #333;
        --text-bright-color: #eee;
        --text-dark-color: #111;
        --button-color: #666;
        --checkbox-color: #666;
        --input-background-color: #222;
        --input-border-color: #777;
        --selected-color: #07f;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        outline: none;
        user-select: none;
        border: none;
        border-radius: 3px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      *:disabled, *:disabled:hover {
        filter: brightness(0.8);
        cursor: not-allowed;
      }

      *:disabled:active {
        scale: 1;
      }

      html {
        font-size: 62.5%;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        font-size: 1.8rem;
        background-color: var(--background-color);
        color: var(--text-bright-color);
        padding: 4px;
      }

      label {
        display: inline-block;
        line-height: 2.8rem;
      }
      
      button {
        margin-top: 4px;
        background-color: var(--button-color);
        color: var(--text-bright-color);
        font-size: 1.8rem;
        padding: 0 2rem;
        line-height: 2.8rem;
        cursor: pointer;
      }

      button:hover, .listItem:hover, .item:hover {
        filter: brightness(1.5);
      }
      
      button:active, .listItem:active, .item:active {
        scale: .975;
      }

      input {
        background-color: var(--input-background-color);
        border: 2px solid var(--input-border-color);
        color: var(--text-bright-color);
        font-size: 1.8rem;
      }

      input[type=number] {
        text-align: right;
        direction: rtl;
        padding: 0 3px;
      }

      input[type=text] {
        padding: 0 6px;
      }

      input[type=range] {
        cursor: pointer;
      }

      input[type=checkbox]{
        height: 0;
        width: 0;
        visibility: hidden;
      }

      .checkLabel {
        top: 2px;
        cursor: pointer;
        text-indent: -9999px;
        width: 5rem;
        height: 2.8rem;
        background: var(--input-background-color);
        border-radius: 1.4rem;
        border: 2px solid var(--input-border-color);
        position: relative;
      }

      .checkLabel:after {
        content: '';
        position: absolute;
        top: .3rem;
        left: .3rem;
        width: 1.8rem;
        height: 1.8rem;
        background: var(--checkbox-color);
        border-radius: 2rem;
      }

      input:checked + .checkLabel:after {
        background: var(--selected-color);
      }

      input:checked + .checkLabel:after {
        left: calc(100% - .3rem);
        transform: translateX(-100%);
      }

      select {
        border: 2px solid var(--input-border-color);
      }
 
      select, select > option {
        background-color: var(--input-background-color);
        color: var(--text-bright-color);
        font-size: 1.7rem;
      }

      input:disabled + .checkLabel {
        filter: brightness(0.6);
      }

      hr {
        margin: 1rem 0;
        width: 100%;
        border: 1px solid #fff4;
      }

      h1 {
        font-size: 2.4rem;
        line-height: 3.2rem;
        color: var(--sub-heading-color);
      }

      h2 {
        line-height: 3.4rem;
        color: var(--sub-heading-color);
      }

      textarea {
        font-family: 'Courier New', Courier, monospace;
        width: 100%;
        height: 100%;
        resize: none;

        background-color: var(--input-background-color);
        border: 2px solid var(--input-border-color);
        color: var(--text-bright-color);
        padding: 4px;

        font-size: 1.2rem;
      }

      textarea::placeholder {
        border-radius: 5px;
        font-size: 1.8rem;
        font-weight: 400;      
      }
      
      .row {
        width: 100%;
      }

      .container {  display: grid;
        grid-template-columns: 0.1fr 0.24fr 0.24fr 0.18fr 0.24fr;
        grid-template-rows: auto 0.8fr auto 1fr;
        grid-auto-columns: 1fr;
        gap: 3px 3px;
        grid-auto-flow: row;
        grid-template-areas:
          "header header header header header"
          "pasteContainer logContainer htmlContainer cssContainer jsContainer"
          "controls controls controls controls controls"
          "output output output output output";
        width: 100%;
        height: 100%;
      }

      .header {
        grid-area: header;
        padding: 4px;
        font-weight: 500;
      }

      .pasteContainer {
        grid-area: pasteContainer;
      }

      .logContainer {
        grid-area: logContainer;
      }

      .htmlContainer {
        grid-area: htmlContainer;
      }

      .cssContainer {
        grid-area: cssContainer;
      }

      .jsContainer {
        grid-area: jsContainer;
      }

      .controls {
        grid-area: controls;
      }

      .output {
        grid-area: output;
      }

      .pasteContainer, .logContainer, .htmlContainer, .cssContainer, .jsContainer, .output {
        display: grid;
        grid-template-rows: auto 1fr;
      }

      .centered {
        text-align: center;
      }

      #in1 {
        color: #777;
      }

      #log1 {
        color: #eef;
      }

      #html1 {
        color: #fe0;
      }


      #js1 {
        color: #fa0;
      }

      #css1 {
        color: #2ae;
      }

      #out1 {
        color: #afa;
      }

    </style>
	</head>

  <body>
    <div class="container">
      <div class="header">
        ShrinkWrap - An HTML, CSS, and JavaScript minifier and compressor,based on <a href="https://github.com/xem/js13k-pack" target="_blank">js13k-pack by xem</a><br>
      </div>
      <div class="pasteContainer">
        <label class="centered">&nbsp;</label>
        <textarea id=in1 spellcheck=false placeholder="Paste your HTML here to begin. Linked and embedded CSS and JS files are okay."></textarea>
      </div>
      <div class="logContainer">
        <label class="centered">LOG</label>
        <textarea id=log1 spellcheck=false readonly></textarea>
      </div>
      <div class="htmlContainer">
        <label class="centered">HTML</label>
        <textarea id=html1 spellcheck=false readonly></textarea>
      </div>
      <div class="cssContainer">
        <label class="centered">CSS</label>
        <textarea id=css1 spellcheck=false readonly></textarea>
      </div>
      <div class="jsContainer">
        <label class="centered">JS</label>
        <textarea id=js1 spellcheck=false readonly></textarea>
      </div>

      <div class="controls">
        <div class=row>

          <label>Minify code</label>
          <input id="minifyCodeCheckbox" type="checkbox" checked/>
          <label class="checkLabel" for="minifyCodeCheckbox">Toggle</label>

          <label>&nbsp;Terser Passes</label>
          <input type="number" id="terserPassesInput" min="1" max="10" step="1" value="2">

          <label>&nbsp;Don't mangle</label>
          <input type="text" id="dontMangleInput">
          <button onclick="saveOptions();">Save</button>

          <label>&nbsp;Unsafe tersing</label>
          <input id="terserUnsafeCheckbox" type="checkbox"/>
          <label class="checkLabel" for="terserUnsafeCheckbox">Toggle</label>

          <label>&nbsp;Zip output</label>
          <input id="zipCodeCheckbox" type="checkbox" checked/>
          <label class="checkLabel" for="zipCodeCheckbox">Toggle</label>

          <label>&nbsp;RoadRoll output</label>
          <select id="roadrollerStrengthSelect">
            <option selected>No</option>
            <option>Light</option>
            <option>Strong</option>
          </select>

          &nbsp;<button id="startMinificationButton" disabled>ShrinkWrap</button>
          &nbsp;<button onclick="downloadZip();" id="downloadZipButton" disabled>Download ZIP</button>

        </div>
      </div>

      <div class="output">
        <label class=centered>OUTPUT</label>
        <textarea id=out1 spellcheck=false readonly></textarea>
      </div>
    </div>

    <script src=terser.5.14.1.js></script>
    <script src="jszip.min.js"></script>
    <script src="zopfli/libzopfli.js"></script>
    <script src="zopfli/compress.js"></script>
    <script src="zopfli/byte-b64.js"></script>

    <script type=module>
      import { ResourcePool, Packer } from "./rr/index.js";

      const resourcePool = new ResourcePool(); // This should persist.

      const imageUrls = new Set(); // Stores all found image URLs.

      const log = t => {
        log1.value += t + '\n';
        log1.scrollTop = log1.scrollHeight;
      }

      let linkedStyleSheets = [];
      let linkedScripts = [];

      let zipzop64; // Our encoded zip file.

      // Save options to localStorage
      const saveOptions = () => {
        // TODO: Implement localStorage saving
        log('Save options function called - implement localStorage here');
      };

      // Load options from localStorage  
      const loadOptions = () => {
        // TODO: Implement localStorage loading
        log('Load options function called - implement localStorage here');
      };

      // Load options on page load
      window.addEventListener('load', loadOptions);

      // Load the text file with the given filename and pass it to the given callback function.
      const loadTextfile = (filename, callback) => {
      fetch(`../${filename}`) // THIS IS YOUR ORIGINAL, CORRECT LINE
        .then(response => response.text())
        .then(data => {
          if (callback) callback(data);
        })
        .catch(error => {
          console.error(`Error loading file ${filename}:`, error);
        });
      }

      // Queue the next linked style sheet for loading and if there are no more, then begin loading linked scripts.
      const queueNextLinkedStyleSheetForLoading = e => {
        if (linkedStyleSheets.length) {
          loadLinkedStyleSheet(linkedStyleSheets.pop()); // Load the next file.
        } else {
          queueNextLinkedScriptForLoading(); // Start linked scripts loading.
        }
      };

      // Recursively load linked stylesheets.
      const loadLinkedStyleSheet = filename => {
        log(`loading linked stylesheet (${filename})...`);
        loadTextfile(filename, data => {
          log('processing stylesheet');
          css1.value += data;
          queueNextLinkedStyleSheetForLoading();
        });
      };

      // Queue the next linked script for loading and if there are no more, then begin minification.
      const queueNextLinkedScriptForLoading = e => {
        if (linkedScripts.length) {
          loadLinkedScript(linkedScripts.shift()); // Load the next file. We use shift because the files will be in the reverse order.
        } else {
          log('preprocessing completed.\n\nSet options and click "ShrinkWrap" button to continue.\n');
          startMinificationButton.disabled = false;
        }
      };
      
      function removeClippedCode(data, language) {

        // const regexMap = {
        //   js: /\/\/beginclip[\s\S]*?\/\/endclip/g,
        //   css: /\/\*beginclip\*\/[\s\S]*?\/\*endclip\*\//g,
        //   html: /<!--beginclip-->[\s\S]*?<!--endclip-->/g,
        // }; // This line produces a linter error but it totally fine.
        
        const regexMap = {
          js: /^\s*\/\/beginclip[\s\S]*?^\s*\/\/endclip/gm,
          css: /^\s*\/\*beginclip\*\/[\s\S]*?^\s*\/\*endclip\*\//gm,
          html: /^\s*<!--beginclip-->[\s\S]*?^\s*<!--endclip-->/gm,
        };

        const regex = regexMap[language];
        if (!regex) return data;
        return data.replace(regex, '');
      }

      function remapJavascript(data) {
        if (!data.trim().startsWith('/*remap')) return data;
        const remapBlockRegex = /^\s*\/\*remap([\s\S]*?)\*\//;
        const match = data.match(remapBlockRegex);
        if (!match) return data;
        const replacements = match[1].split('\n').map(line => line.trim()).filter(line => line.includes(',')).map(line => {
          const parts = line.split(',');
          return { from: parts[0].trim(), to: parts[1].trim() };
        }).filter(pair => pair.from && pair.to);
        if (replacements.length === 0) return data;
        let processedData = data;
        for (const replacement of replacements) {
          processedData = processedData.replaceAll(replacement.from, replacement.to);
        }
        return processedData;
      }

      // Recursively load linked scripts.
      const loadLinkedScript = filename => {
        log(`loading linked script (${filename})...`);
        loadTextfile(filename, data => {
          log('processing script');
          data = remapJavascript(data); // Perform custom replacements.
          data = removeClippedCode(data, 'js');
          js1.value += data;
          queueNextLinkedScriptForLoading();
        });
      };

      // The main handler is now async to allow for fetching images before processing.
      startMinificationButton.onclick = async e => {
        out1.value = '';
        log1.value = '\n';
        let minificationStartTime = performance.now();
        let start;

        // Step 1: Fetch all images and rewrite paths before doing anything else.
        log(`Processing ${imageUrls.size} images...`);

        const fetchImage = async (url) => {
          try {
            // url is an absolute path like 'http://localhost:8000/project/image.png'
            // We need to get the relative path for your fetch, e.g., 'image.png'
            const filename = url.substring(url.lastIndexOf('/') + 1);
            
            const response = await fetch(`../${filename}`);
            
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const blob = await response.blob();
            const localPath = filename; // This remains correct for the flat zip structure
            log(`  - Fetched ${filename}`);
            return { originalUrl: url, localPath, blob };
          } catch (error) {
            log(`  - FAILED to fetch ${url}: ${error.message}`);
            return null;
          }
        };

        const fetchedImageResults = await Promise.all(
          Array.from(imageUrls).map(url => fetchImage(url))
        );
        const successfulFetches = fetchedImageResults.filter(result => result !== null);

        if (successfulFetches.length > 0) {
          log('\nRewriting image paths...');
          let currentHtml = html1.value;
          let currentCss = css1.value;
          for (const { originalUrl, localPath } of successfulFetches) {
            currentHtml = currentHtml.replaceAll(originalUrl, localPath);
            currentCss = currentCss.replaceAll(originalUrl, localPath);
          }
          // Update the textareas with the rewritten content
          html1.value = currentHtml;
          css1.value = currentCss;
          log('Path rewriting complete.');
        }

        log(`Minify code: ${(minifyCodeCheckbox.checked) ?'yes' :'no'}`);
        log(`Terser passes: ${terserPassesInput.value}`);
        log(`Don't mangle: ${dontMangleInput.value || '(none)'}`);
        log(`Unsafe tersing: ${(terserUnsafeCheckbox.checked) ?'yes' :'no'}`);
        log(`Roadroll: ${['none', 'light', 'strong'][roadrollerStrengthSelect.selectedIndex]}`);
        log(`Zip output: ${(zipCodeCheckbox.checked) ?'yes' :'no'}\n`);

        let js = js1.value.replace(/;+$/, ";");

        // log("raw size: " + (html1.value + "<script>" + js + "<\/script>" + (css1.value ? ("<style>" + css1.value) : "")).length + " bytes");
        let totalLength = (html1.value + "<script>" + js + "<\/script>" + (css1.value ? ("<style>" + css1.value) : "")).length;
        log("raw size: " + totalLength.toLocaleString('en-US') + " bytes");

        if (minifyCodeCheckbox.checked) {
          start = performance.now();
          setTimeout(() => {
            log("Starting Terser minification...");
            
            // Build Terser options with mangle configuration
            const terserOptions = {
              toplevel: true,
              compress: {
                passes: terserPassesInput.value * 1, 
                unsafe: terserUnsafeCheckbox.checked, 
                pure_getters: true,
                ecma: 2015,  // Enable ES6+ optimizations
                keep_fnames: false,
                properties: false  // Don't mangle object properties to preserve shorthand syntax
              },
              output: {
                shorthand: true  // Force preserve shorthand properties
              }
            };

            // Add mangle options if don't mangle input has values
            const dontMangleList = dontMangleInput.value.trim();
            if (dontMangleList) {
              const reserved = dontMangleList.split(',').map(s => s.trim()).filter(s => s);
              if (reserved.length > 0) {
                terserOptions.mangle = {
                  reserved: reserved
                };
              }
            }

            Terser.minify(js, terserOptions).then(terser => {
              if (terser.code) js = terser.code;
              log(`Terser minification completed (${(performance.now() - start) | 0}ms).`);
              continueMinification();
            });
          }, 0);
        } else {
          continueMinification();
        }

        function continueMinification() {
          start = performance.now();
          const rr = roadrollerStrengthSelect.selectedIndex;

          if (rr === 1 || rr === 2) {
              const strength = rr === 1 ? 'Light' : 'Strong';
              log(`Starting Roadroller optimization (${strength})...`);
              const inputs = [{ data: js, type: 'js', action: 'eval' }];
              const packer = new Packer(inputs, { resourcePool });
              
              new Promise(resolve => setTimeout(resolve, 0)).then(() => {
                  try {
                      packer.optimize(rr);
                      const { firstLine, secondLine } = packer.makeDecoder();
                      js = firstLine + secondLine;
                      log(`Roadroller optimization (${strength}) completed (${(performance.now() - start) | 0}ms).`);
                  } catch (error) {
                      log(`Error during Roadroller optimization: ${error}`);
                  }
                  finishMinification();
              });
          } else {
            finishMinification();
          }
        }

        function finishMinification() {
          log(`\nMinifing CSS`);
          let css = css1.value;
          css = removeClippedCode(css, 'css');
          css = css.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\s+/g, ' ').trim().replace(/\s*:\s*/g, ':').replace(/\s*;\s*/g, ';').replace(/\s*{\s*/g, '{').replace(/\s*}\s*/g, '}').replace(/\s*,\s*/g, ',').replace(/\s*!/g, '!').replace(/;}/g, '}');
          
          log(`Minifing HTML`);
          let html = html1.value;
          html = removeClippedCode(html, 'html');
          html = html.replace(/<!--[\s\S]*?-->/g, '').replace(/\s+/g, ' ').trim().replace(/>\s+</g, '><');
          
          log(`Creating output`);
          if (css) {
              const styles = `<style>${css}</style>`;
              const headCloseIndex = html.indexOf('<\/head>');
              html = (headCloseIndex !== -1) ? html.slice(0, headCloseIndex) + styles + html.slice(headCloseIndex) : html + styles;
          }

          const scripts = `<script>${js}<\/script>`;
          const bodyCloseIndex = html.indexOf('<\/body>');
          html = (bodyCloseIndex !== -1) ? html.slice(0, bodyCloseIndex) + scripts + html.slice(bodyCloseIndex) : html + scripts;

          out1.value = html;
          log(`Output size: ${(out1.value.length).toLocaleString('en-US')} bytes`);

          if (zipCodeCheckbox.checked) {
            start = performance.now();
            log('\nZipping output');
            
            // Use JSZip for multi-file support (HTML + images).
            // We no longer use the custom Zopfli functions directly here, as JSZip handles the container.
            const zip = new JSZip();
            zip.file("index.html", html);

            for (const { localPath, blob } of successfulFetches) {
                zip.file(localPath, blob);
            }

            zip.generateAsync({
                type: "base64",
                compression: "DEFLATE",
                compressionOptions: { level: 9 } // Max standard DEFLATE compression
            }).then(function(base64) {
                zipzop64 = base64;
                downloadZipButton.disabled = false;
                log(`Zipping complete (${(performance.now() - start) | 0}ms).`);
                
                const binaryString = window.atob(base64);
                const zippedSize = binaryString.length;

                const maxSize = 1024 * 13;
                const remainingSize = maxSize - zippedSize;
                const percentage = (zippedSize / maxSize) * 100;

                log("Zip file: " + zippedSize.toLocaleString('en-US') + " bytes.");
                log(`\n${zippedSize.toLocaleString()} bytes of ${maxSize.toLocaleString('en-US')} used (${percentage.toFixed(2)}%), ${remainingSize.toLocaleString('en-US')} bytes remaining.`);
            });

          } else {
              // This line was causing an error if downloadZipButton didn't exist, changed to your original dl1
              // dl1.style.color = "transparent"; 
          }
          
          log(`\nMinification completed (${(performance.now() - minificationStartTime) | 0}ms).\n`);
        }
      };

      // The download function was missing, added it back.
      const downloadZip = () => {
        if (!zipzop64) return;
        const dl1 = document.createElement('a');
        dl1.setAttribute("download", "entry.zip");
        dl1.href = "data:application/zip;base64," + zipzop64;
        document.body.appendChild(dl1);
        dl1.click();
        document.body.removeChild(dl1);
      };
      downloadZipButton.onclick = downloadZip; // Hook up the button

      // When any text is pasted into the HTML TextInput..
      in1.onpaste = e => {
        startMinificationButton.disabled = downloadZipButton.disabled = true;
        log1.value = '';
        
        imageUrls.clear(); // Clear URLs from previous run

        let html = (e.clipboardData || window.clipboardData).getData('text');
        html1.value = css1.value = js1.value = '';
        linkedScripts = [];
        linkedStyleSheets = [];
        
        let match;
        const scriptRegex = /<script\s+src="([^"]+)"\s*><\/script>/gi;
        while ((match = scriptRegex.exec(html)) !== null) linkedScripts.push(match[1]);
        html = html.replace(scriptRegex, '');
        
        const linkRegex = /<link\s+rel="stylesheet"\s+href="([^"]+)"\s*\/?>/gi;
        while ((match = linkRegex.exec(html)) !== null) linkedStyleSheets.push(match[1]);
        html = html.replace(linkRegex, '');
        
        let done = false;
        while (!done) {
          let start = html.indexOf('<style>');
          let end = html.indexOf('</style>');
          if (start >= 0 && end >= 0) {
            log(`processing embedded style sheet...`);
            css1.value += html.slice(start + 7, end).trim() + '\n';
            html = html.substring(0, start) + html.substring(end + 8);
          } else { done = true; }
        }
        
        done = false;
        while (!done) {
          let start = html.indexOf('<script>');
          let end = html.indexOf('<\/script>');
          if (start >= 0 && end >= 0) {
            log(`processing embedded script...`);
            js1.value += html.slice(start + 8, end).trim() + '\n';
            html = html.substring(0, start) + html.substring(end + 9);
          } else { done = true; }
        }    

        // Find all image URLs in the pasted HTML and extracted CSS
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          doc.querySelectorAll('img[src]').forEach(img => {
            if (img.src && !img.src.startsWith('data:')) {
              const absoluteUrl = new URL(img.src, document.location.origin).href;
              imageUrls.add(absoluteUrl);
            }
          });
          const cssUrlRegex = /url\(['"]?(.+?)['"]?\)/g;
          let cssMatch;
          const tempCss = css1.value;
          while ((cssMatch = cssUrlRegex.exec(tempCss)) !== null) {
            if (!cssMatch[1].startsWith('data:')) {
              const absoluteUrl = new URL(cssMatch[1], document.location.origin).href;
              imageUrls.add(absoluteUrl);
            }
          }
          if (imageUrls.size > 0) {
            log(`Found ${imageUrls.size} unique image URLs to process.`);
          }
        } catch (err) {
          log(`Error parsing for images: ${err}`);
        }

        html1.value = html;
        queueNextLinkedStyleSheetForLoading();
      };
    </script>
  </body>
</html>